my_interaction = {
	# Used for interaction menus. Sorts interactions based on this value after categorization
	# (higher values appear first), and determines whether to put them in the More... menu
	interface_priority = number

	# Used for interaction menus. Common interactions are never put into the More... sub-menu
	common_interaction = yes/no

	# Required! Used for interaction menus. Groups interactions into this category
	category = interaction_category_hostile

	# Used for ToggleFilteredCharacterInteractionMenu
	# Opens a subset of the interaction menu, showing only interactions with matching
	# filter_tag or category
	# These are localized with the _filter_tag_desc suffix when displayed in the interaction menu
	filter_tags = { string1 string2 }

	# What icon to use. If one icon is used for multiple interactions,
	# consider making it generic (e.g., icon_culture for
	# culture-related interactions, or icon_personal for personal schemes).
	# Otherwise defaults to none/my_interaction key +
	# relevant my_interaction.dds in gfx/interface/icons/character_interactions
	icon = key

	# Used to define the background image used by the interaction window. These can use triggers.
	#
	# Root scope is the interaction's scope:actor. If
	# no background is defined or no valid background exists, the interaction GUI will default to
	# "study"
	override_background = { reference = relaxing_room }

	# Whether the interaction should be highlighted in the interaction menu.
	# Not highlighted if is_valid or is_valid_showing_failures_first is false
	is_highlighted = trigger

	# Tooltip message when highlighted in the menu
	highlighted_reason = loc_key

	on_decline_summary = dynamic description		# Flavor text displayed below the accept control
	# Use when you need to draw more attention to the decline effect

	# This interaction uses a specialized GUI
	special_interaction = type

	# This interaction runs specialized code, identified by this tag
	special_ai_interaction = type

	# What interface does the interaction use?
	interface = call_ally/marriage/grant_titles/etc.

	# What custom character sorting options should the interaction provide?
	# The last defined option will be displayed first in the dropdown list.
	#
	# Current options:
	#	candidate_score (requires target title)
	#	governor_efficiency
	#	obedience
	#	merit
	custom_character_sort = { }

	# Type of scheme initiated by the interaction
	scheme = elope/murder/etc.

	# Whether the interaction pops up for the recipient upon receipt
	popup_on_receive = yes

	# If the interaction is auto-accepted, force the diplomatic notification item
	force_notification = yes/no

	# Pause the game upon receipt. Usually should be combined with popup_on_receive
	pause_on_receive = yes/no

	# If the interaction is rejected, negotiations will begin. We won't show "will not accept" etc.,
	# because it's still possible to accept the interaction through a negotiation event chain
	ai_accept_negotiation = yes/no

	# Is the interaction hidden?
	hidden = yes

	# Does the interaction check diplomatic distance?
	# Default is yes
	use_diplomatic_range = yes/no/trigger

	# Interaction can be sent and AI might reject
	can_send_despite_rejection = yes

	# If the actor is a player, and the recipient
	# has already received a pending interaction reply from them, whether this interaction can still be sent.
	# Default is no
	ignores_pending_interaction_block = yes

	# Name of the interaction after sending. Defaults to database object key
	send_name = loc_key

	# Whether the interaction needs a recipient to open the interaction window
	# Very rare case, when the interaction is opened from other UI elements instead of the right-click menu
	# Recipient must eventually be set via redirect or code
	# Unless there is code support or a very special use case, this option should almost never be set to `no`
	# Default is yes
	needs_recipient_to_open = yes

	# Whether interaction effects should be displayed in the notification window
	# when the interaction is sent.
	# Default is yes
	show_effects_in_notification = no

	# If this interaction should be performed by a diarch,
	# including non-rulers
	diarch_interaction = no

	# Default is gfx/interface/icons/
	# character_interactions/my_interaction_alert.dds
	alert_icon = texture_path

	# Default is gfx/interface/icons/
	# character_interactions/my_interaction_small.dds
	icon_small = texture_path

	# When to display an extra icon.
	# Tooltip key is <key>_extra_icon
	should_use_extra_icon = { always = yes }

	# Icon displayed when should_use_extra_icon is true
	extra_icon = "gfx/<...>/hook_icon.dds"

	# Possible types:
	#	title
	#	artifact
	#	men_at_arms
	#	court_position_type
	#	count (default)
	target_type = type

	# See possible types in FAQ
	target_filter = type

	# AI intermediary's answer is random
	ai_intermediary_maybe = no

	# AI's answer is random
	ai_maybe = yes

	# Minimum days before AI reply
	ai_min_reply_days = 4

	# Maximum days before AI reply
	ai_max_reply_days = 9

	# Short description of the interaction
	desc = loc_key

	# Set the tone of the request text
	greeting = negative/positive

	# Request text displayed to the intermediary
	intermediary_notification_text = loc_key

	# Request text displayed to the recipient
	notification_text = loc_key

	# Text that should be displayed below the portrait?
	# (e.g., "Select Guardian")
	prompt = loc_key

	# How long before the interaction can be used again?
	cooldown = { years = x }

	# How long before the interaction can be used against the recipient again?
	cooldown_against_recipient = { years = x }

	# Under what circumstances can the interaction be used against the recipient,
	# despite a cooldown period against that recipient?
	ignore_recipient_recieve_cooldown = trigger

	# Applies a cooldown period to all interactions of the same category as this interaction
	#
	# If the interaction already has a cooldown,
	# the longer cooldown will be applied
	category_cooldown = { years = x }

	# Applies a cooldown period to all interactions of the same category and against
	# this recipient
	#
	# If the interaction already has a cooldown,
	# the longer cooldown will be applied
	category_cooldown_against_recipient = { years = x }

	# Whether the interaction is available and visible
	#
	# Avoid placing triggers here that only test actor or global visibility state
	# Please place these triggers in is_available - this will make the AI faster and better
	#
	# Available scopes:
	#	scope:actor
	#	scope:recipient
	is_shown = trigger

	# Whether the interaction is selectable in the current setting, trigger only shows failure conditions
	# Available scopes:
	#	scope:actor
	#	scope:recipient
	is_valid_showing_failures_only = trigger

	# Whether the interaction is selectable in the current setting
	# Available scopes:
	#	scope:actor
	#	scope:recipient
	is_valid = trigger

	# Whether the target is valid, trigger only shows failure conditions
	has_valid_target_showing_failures_only = trigger

	# Whether the target is valid
	has_valid_target = trigger

	# Whether this character can be picked as a valid target
	can_be_picked = trigger

	# Whether this title can be picked as a valid target
	can_be_picked_title = trigger

	# Whether this artifact can be picked as a valid target
	can_be_picked_artifact = trigger

	# Whether this regiment can be picked as a valid target
	can_be_picked_regiment = trigger

	# Whether a confirmation window needs to be opened for the player upon selection; defaults to true if unspecified
	# If evaluated as false, on_send / on_accept will run immediately upon selection
	# Deprecated! Can be used to trigger game state change effects, which should always inform the player in advance! Will be removed in TIT-64917
	needs_confirmation = trigger

	# Whether the interaction is auto-accepted,
	# or the recipient can decide
	auto_accept = yes/no/trigger

	# Whether the interaction can be sent?
	can_send = trigger

	# Whether the interaction can be blocked by the recipient
	# (e.g., via a hook on the actor)
	can_be_blocked = trigger

	# Effect changes character interaction scope - replaces any actor, secondary actor, recipient,
	# secondary recipient, and intermediary with any other character
	# Available scopes:
	#	scope:actor
	#	scope:secondary_actor
	#	scope:recipient
	#	scope:secondary_recipient
	#	scope:intermediary
	redirect = {}

	# Everyone is categorized into the 'characters' list,
	# potentially displayed for selection.
	#
	# Uses scopes for actor, recipient,
	# secondary actor, and secondary recipient.
	populate_actor_list = {}

	# Same as populate_actor_list
	populate_recipient_list = {}

	# To be able to use values in loc
	# (e.g., RANSOM_COST =
	# scope:secondary_recipient.ransom_cost_value
	# allows you to use $RANSOM_COST|0$ in loc)
	localization_values  = {}

	# Text displayed above the options block - general description of all options
	options_heading = loc_key

	# Add options
	send_option = {

		# Whether the option is displayed. Independent trigger - do not
		# reference any other option flags to avoid logic errors
		is_shown = trigger

		# Whether the option is selectable
		is_valid = trigger

		# Tooltip message
		current_description = desc

		# If selected, scope:flag_name will be set to yes
		flag = flag_name

		# loc_key for the option label
		localization = loc_key

		# Trigger for whether this option should be enabled when the window opens.
		# Defaults to off if undefined
		starts_enabled = trigger

		# Trigger for whether this option can be changed from its default value
		can_be_changed = trigger

		# If yes, when the AI selects the interaction,
		# it will perform a full can send check instead of the more performance-efficient
		# recipient rejection and ai will do checks; use with caution and perform performance analysis
		can_invalidate_interaction = bool
	}

	# Options should avoid blocking interaction sending (unless the recipient rejects),
	# because we assume this in the AI for performance;
	# if re-checking is needed, use can_invalidate_interaction

	# Are options mutually exclusive?
	# Non-exclusive options can seriously harm AI performance
	# Ensure only 4 or 5 non-exclusive options pass the is_shown trigger at any given time
	# But many rarely visible options are fine
	send_options_exclusive = yes/no

	# Are secondary scope targets optional?
	secondary_scopes_optional = yes/no

	# Executed directly when the interaction is sent
	on_send = effect

	# Executed when the recipient accepts
	# (only after intermediary acceptance)
	on_accept = effect

	# Executed when the recipient declines
	# (only after intermediary acceptance)
	on_decline = effect

	# Executed when the recipient blocks
	# (only after intermediary acceptance)
	on_blocked_effect = effect

	# Executed only when the interaction is auto-accepted.
	# Completed before any other side effects
	# (e.g., hardcoded marriage, etc.)
	pre_auto_accept = effect

	# Executed only when the interaction is auto-accepted
	on_auto_accept = effect

	# Executed when the intermediary allows the interaction to occur.
	# Followed by the recipient's decision
	on_intermediary_accept = effect

	# Executed when the intermediary rejects the interaction.
	# It prevents any effects from being called on the recipient
	on_intermediary_decline = effect

	# loc key displayed in the interaction item tooltip.
	# Receives the interaction name in $INTERACTION$.
	# Default value "INTERACTION_REPLY_ITEM"
	reply_item_key = loc_key


	### These loc keys are displayed to the player when sending an interaction.
	### What the meaning will be is the target's answer.

	# loc key when the interaction will be accepted.
	# Default value "ANSWER_YES"
	pre_answer_yes_key = loc_key

	# loc key when the interaction will not be accepted.
	# Default value "ANSWER_NO"
	pre_answer_no_key = loc_key

	# loc key when the interaction might be accepted.
	# Receives the acceptance value in $VALUE$.
	# Default value "ANSWER_MAYBE"
	pre_answer_maybe_key = loc_key

	# Acceptance breakdown summary title when the recipient accepts
	pre_answer_yes_breakdown_key = ANSWER_WILL_ACCEPT

	# Acceptance breakdown summary title when the recipient rejects
	pre_answer_no_breakdown_key = ANSWER_WILL_NOT_ACCEPT

	# Acceptance breakdown summary title when the recipient's answer is random
	pre_answer_maybe_breakdown_key = ANSWER_SUM_MAYBE

	# Acceptance breakdown summary title when the intermediary accepts
	intermediary_breakdown_yes = ANSWER_WILL_ACCEPT

	# Acceptance breakdown summary title when the intermediary rejects
	intermediary_breakdown_no = ANSWER_WILL_NOT_ACCEPT

	# Acceptance breakdown summary title when the intermediary's answer is random
	intermediary_breakdown_maybe = ANSWER_SUM_MAYBE


	### These loc keys are displayed to the player when answering an interaction.

	# Intermediary accept interaction button text
	intermediary_answer_accept_key = ANSWER_YES

	# Intermediary reject interaction button text
	intermediary_answer_reject_key = ANSWER_NO

	# Recipient block interaction text
	answer_block_key = ANSWER_BLOCK

	# Recipient accept interaction button text
	answer_accept_key = ANSWER_YES

	# Recipient reject interaction button text
	answer_reject_key = ANSWER_NO

	# Recipient confirm interaction button text.
	# Used to notify what has happened
	answer_acknowledge_key = ANSWER_ACKNOWLEDGE


	# Scripted cost of the interaction.
	# If the actor cannot pay, the interaction will be disabled,
	# and the cost will be deducted from the actor when the interaction is sent.
	# Renown can only be spent by the dynasty.
	cost = {
		piety = {}
		prestige = {}
		gold = {}
		renown = {}
	}

	# Will the AI respond immediately instead of pretending to think for N days?
	ai_instant_response = yes/no

	# Set scope:target to make the AI target a specific object.
	# Title target interactions do not need this
	ai_set_target = {}

	ai_targets = {
		# Which characters the AI considers as recipients of the interaction,
		# scripts can be written multiple times to combine lists
		#
		# Available lists are in the "ai_targets" section of this file
		# (attempting to add an invalid list will trigger an error message showing all available lists)
		ai_recipients = type

		# Maximum number of targets to consider; if not set, all targets are considered,
		# also considers random targets it filters
		max = integer

		# Lower probability, e.g., 0.25, randomly excludes that number of characters from checking
		# This is useful for saving performance
		chance = 0-1

		# Parameters for specifying details for specific targets
		# Only used for "situation_participant_group" targets
		# Key specifying the situation. Defaults to empty
		parameter = ""
	}

	# Quick triggers for ai_targets
	ai_target_quick_trigger = {

		# Target must be an adult
		adult = yes

		# Target must be attracted to the owner
		attracted_to_owner = yes

		# Owner must be attracted to the target
		owner_attracted = yes

		# Target must be in prison
		prison = yes
	}

	# How often the AI should consider performing this interaction
	ai_frequency = months

	# How often the AI should consider this interaction based on the rank of the highest title (in months).
	# '0' means never consider. Used as an alternative to 'ai_frequency'.
	# All ranks must be defined.
	ai_frequency_by_tier = {
		barony = 0
		county = 10
		duchy = 2
		kingdom = 1
		empire = 1
		hegemony = 1
	}

	# Whether the AI will consider trying this interaction.
	# Root scope is the actor, other event targets are unavailable
	#
	# !!! Deprecated - all interactions should use is_available instead
	#	ai_potential = trigger

	# Whether this interaction is available to the actor, including AI and players
	# Available scopes:
	#	root - actor
	is_available = trigger

	# Whether the AI intermediary will approve this interaction and forward it to the recipient
	ai_intermediary_accept = mtth

	# Whether the AI will accept this interaction request
	ai_accept = mtth

	# AI's level of interest in sending this interaction (tested after selecting a target)
	# 0-100 percentage chance, will be clamped within range.
	#	ai_will_do = mtth

	### Note that for title interactions, each individual target title is evaluated,
	### and the one giving the highest ai_will_do will be used.
	### If the interaction has options, the combination of options giving the highest ai_will_do will be used.
}
## FAQ
Q: What does the special interaction type arrange_marriage_interaction do?
A: special_interaction = arrange_marriage_interaction adds extra marriage information to the interaction
This information causes the game to display a special marriage interface when setting up or replying to the interaction.
It is also used by the AI to know which interaction to use when setting up a marriage.
It automatically marries/betroths secondary participants, establishes alliances, and assigns prestige.

Q: What do "secondary_actor = marriage" and "secondary_recipient = marriage" do?
A: It indicates that the interaction has secondary participants (the people actually getting married), and
 we can change them in the interface. It also automatically redirects the interaction to the matchmaker
 so players can arrange a marriage with another ruler's son/daughter, with the child as the secondary recipient and the ruler as the recipient (since they will be the one accepting or rejecting).
 It also sets the list of selectable characters from the actor/recipient and their court and children.

Q: What do "secondary_actor = marry_off" and "secondary_recipient = marry_off" do?
A: Very similar to marriage, but with some exceptions:

- The character list is calculated from all living characters who can marry.
- Redirection makes the character you are interacting with the secondary actor (since you are the one marrying them off)
- There is a marriage redirection for anyone you choose for them to marry (i.e., primarily the employer)
Q: How and when are character interaction triggers checked?
A: These are the main triggers used by interactions:

- is_shown
- is_highlighted
- is_valid_showing_failures_only
- is_valid
- has_valid_target_showing_failures_only
- has_valid_target
- can_be_picked
- can_be_picked_title
- can_be_blocked
- can_send
Q: What are the possible types for target_filter?
A: Possible types:

- actor_domain_titles
- recipient_domain_titles
- secondary_actor_domain_titles
- secondary_recipient_domain_titles
- actor_domain_titles_including_leases
- recipient_domain_titles_including_leases
- secondary_actor_domain_titles_including_leases
- secondary_recipient_domain_titles_including_leases
- actor_de_jure_titles
- recipient_de_jure_titles
- secondary_actor_de_jure_titles
- secondary_recipient_de_jure_titles
- actor_realm_titles
- recipient_realm_titles
- secondary_actor_realm_titles
- secondary_recipient_realm_titles
- actor_top_liege_de_jure_titles
- recipient_top_liege_de_jure_titles
- secondary_actor_top_liege_de_jure_titles
- secondary_recipient_top_liege_de_jure_titles
- actor_artifacts
- recipient_artifacts
- actor_artifacts_claimable
- recipient_artifacts_claimable
- actor_maa
- recipient_maa
- actor_personal_maa
- recipient_personal_maa
- actor_title_maa
- recipient_title_maa
- count (default)
## Interaction Trigger Check Timing and Special Behavior
### Interaction Sending Check Flow
The test for whether an interaction can be sent is as follows:

- Check if set to sendable (this means all targets and secondary actors/recipients used by the interaction must have been selected)
- Check diplomatic distance (if the interaction script is set to use it)
- Perform special is_shown check determined by special_interaction =
- Trigger: is_shown
- Check if the recipient is already considering this interaction
- Trigger: is_valid_showing_failures_only
- Trigger: has_valid_target_showing_failures_only
- Trigger: can_send
- Trigger: is_valid
- Trigger: has_valid_target
- Perform special can_send check determined by special_interaction =
If all the above checks pass, then we check if the interaction needs acceptance (auto_accept = no or trigger failure, and interactions that can be sent like imprisonment)
Interactions requiring acceptance cannot be sent to the AI unless it will accept.

### Title List Population Flow
When populating the title list, we look at:

- Select domain or de jure titles based on target_filter =
- Trigger: can_be_picked_title, with full interaction scope and title set to scope:target
  Note: can_be_picked_title is not checked when we attempt to send; it is a separate trigger that should be a fast way to decide what can eventually enter the selection list
### Character List Population Flow
When populating the character list, we look at:

- secondary_actor/secondary_recipient = determines what to base the list generation on (vassals, court members, marriage, dynasty, family, ...)
If we haven't selected a character yet (many interactions require us to select two characters, like marriage):

- Trigger: can_be_picked, with current interaction scope and test character set to root
Otherwise, if we are selecting the second character:

- Attempt to set the character as secondary_actor/secondary_recipient. After this, the interaction should be fully set up.
- Perform a full Can Send test, but ignore the AI acceptance check.
Note: can_be_picked is only used to filter the first character we need to select, and is not part of the Can Send test.

### Other Check Timings
- Is Shown: is_shown is used by the interface to check if the interaction should be visible in the interaction list
- Is Valid: is_valid and is_valid_showing_failures_only are tested to see if the interaction should be enabled (clickable) in the menu
## ai_targets
The following are valid AI targets:

- known_secrets - characters with secrets you know
- scheme_targets - scheme targets
- hooked_characters - characters who are hooked
- neighboring_rulers - neighboring rulers
- neighboring_rulers_including_tributary_borders - similar to neighboring_rulers, but also includes your tributaries and all their neighbors
- neighboring_top_overlords_including_tributary_borders - similar to neighboring_rulers_including_tributary_borders, but only for the top_overlords of neighboring countries (useful for interactions targeting top suzerains with tributaries as buffers)
- neighboring_top_overlords_connected_by_land - similar to neighboring_top_overlords_including_tributary_borders, but excludes suzerains with no land connection to the relevant neighbor
- peer_vassals - peer vassals
- guests - guests
- dynasty - dynasty
- courtiers - court members
- councillors - advisors
- prisoners - prisoners
- confederation_house_heads - heads of all houses in the character group
- sub_realm_characters - sub-realm characters
- realm_characters - realm characters
- vassals - vassals
- tributaries - tributaries
- liege - liege
- top_liege - top liege
- suzerain - suzerain
- top_suzerain - top suzerain
- self - self
- head_of_faith - head of faith
- spouses - spouses
- family - family
- children - children
- primary_war_enemies - primary war enemies
- war_enemies - war enemies
- war_allies - war allies
- scripted_relations - any character with whom you have a scripted relation
- activity_host - host of an activity you are participating in
- activity_guests - guests of an activity you are participating in
- contacts - people in the contact list (related to task contracts)
- domicile_location_top_ruler - top ruler of the realm where the domicile is located (for domicile owners)
- domicile_location_top_realm_vassals - vassals of the top realm where the domicile is located (for domicile owners)
- domicile_location_neighboring_top_rulers - rulers of neighboring top realms (for domicile owners, uses the top liege of the domicile location to get neighboring realms)
- domicile_location_neighboring_top_realm_vassals - vassals of neighboring top realms (for domicile owners, uses the top liege of the domicile location to get neighboring realms)
- top_realm_domicile_owners - domicile owners located in the top liege's realm (for landless domicile owners, uses the top liege of your location)
- sub_realm_domicile_owners - domicile owners located within your own realm (for landed rulers)
- nearby_domicile_owners - nearby domicile owners (uses the NEARBY_DOMICILE_RANGE value defined in 00_defines.txt)
- situation_participant_group - other characters in the same participant group. Requires using parameter to define the key of the situation to check
